$date
	Thu Dec 08 16:34:01 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module tb_instr_decoder $end
$var wire 1 ! wrd_sel $end
$var wire 1 " wrd_en $end
$var wire 1 # src2_sel $end
$var wire 8 $ src2_addr [7:0] $end
$var wire 8 % src1_addr [7:0] $end
$var wire 1 & set_ifmap_o $end
$var wire 1 ' send_systolic_data $end
$var wire 1 ( send_optimal_move $end
$var wire 1 ) send_layer_info $end
$var wire 8 * rd_addr [7:0] $end
$var wire 1 + pc_sel $end
$var wire 1 , load_weights $end
$var wire 1 - load_bias $end
$var wire 1 . jump_sel $end
$var wire 12 / immediate [11:0] $end
$var wire 1 0 decode_layer_info $end
$var wire 1 1 decode_layer $end
$var wire 1 2 compute_ifmap $end
$var wire 1 3 compute_grid $end
$var wire 3 4 br_funct [2:0] $end
$var wire 3 5 alu_funct [2:0] $end
$var reg 1 6 clk $end
$var reg 32 7 instr [31:0] $end
$scope module u_instruction_decoder $end
$var wire 32 8 instr [31:0] $end
$var wire 1 ! wrd_sel $end
$var wire 1 # src2_sel $end
$var wire 1 + pc_sel $end
$var wire 1 . jump_sel $end
$var parameter 32 9 ARITHMETIC $end
$var parameter 32 : BRANCH $end
$var parameter 32 ; JUMP $end
$var parameter 32 < LOAD $end
$var parameter 32 = SPECIAL $end
$var reg 3 > alu_funct [2:0] $end
$var reg 3 ? br_funct [2:0] $end
$var reg 1 3 compute_grid $end
$var reg 1 2 compute_ifmap $end
$var reg 1 1 decode_layer $end
$var reg 1 0 decode_layer_info $end
$var reg 12 @ immediate [11:0] $end
$var reg 3 A instr_type [2:0] $end
$var reg 1 - load_bias $end
$var reg 1 , load_weights $end
$var reg 8 B rd_addr [7:0] $end
$var reg 1 ) send_layer_info $end
$var reg 1 ( send_optimal_move $end
$var reg 1 ' send_systolic_data $end
$var reg 1 & set_ifmap_o $end
$var reg 8 C src1_addr [7:0] $end
$var reg 8 D src2_addr [7:0] $end
$var reg 1 " wrd_en $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b100 =
b11 <
b10 ;
b1 :
b0 9
$end
#0
$dumpvars
b0 D
b0 C
b0 B
b0 A
b0 @
b111 ?
b0 >
b0 8
b0 7
16
b0 5
b111 4
03
02
01
00
b0 /
0.
0-
0,
0+
b0 *
0)
0(
0'
0&
b0 %
b0 $
0#
1"
0!
$end
#5
06
#10
b10101 *
b10101 B
b1101 $
b1101 D
b1100 %
b1100 C
b1 5
b1 >
16
b100000001100011010000000010101 7
b100000001100011010000000010101 8
#15
06
#20
1#
b1000 *
b1000 B
b1 /
b1 @
b0 $
b0 D
b0 %
b0 C
b0 5
b0 >
16
b10000000000000000000001001000 7
b10000000000000000000001001000 8
#25
06
#30
1+
0#
0"
b0 *
b0 B
b1011 /
b1011 @
b111 $
b111 D
b1000 %
b1000 C
b11 4
b11 ?
b111 5
b111 >
b1 A
16
b1100100001000001110000000001011 7
b1100100001000001110000000001011 8
#35
06
#40
1.
0+
b11001001 /
b11001001 @
b0 $
b0 D
b0 %
b0 C
b111 4
b111 ?
b10 A
16
b11100011100000000000000011001001 7
b11100011100000000000000011001001 8
#45
06
#50
0.
1!
1#
1"
b1011 *
b1011 B
b10101011 /
b10101011 @
b0 5
b0 >
b11 A
16
b11000000000000010101011001011 7
b11000000000000010101011001011 8
#55
06
#60
1.
1+
1-
0"
b0 *
b0 B
b0 /
b0 @
b111 5
b111 >
b100 A
16
b11111111100000000000000110000000 7
b11111111100000000000000110000000 8
#65
06
#70
1'
0-
16
b11111111100000000000000111000000 7
b11111111100000000000000111000000 8
#75
06
#80
1&
0'
16
b11111111100000000000001000000000 7
b11111111100000000000001000000000 8
#85
06
#90
0&
10
16
b11111111100000000000000010000000 7
b11111111100000000000000010000000 8
#95
06
#100
16
#105
06
#110
16
#115
06
#120
16
#125
06
#130
16
#135
06
#140
16
#145
06
#150
16
#155
06
#160
16
#165
06
#170
16
#175
06
#180
16
#185
06
#190
16
#195
06
#200
16
#205
06
#210
16
#215
06
#220
16
#225
06
#230
16
#235
06
#240
16
#245
06
#250
16
#255
06
#260
16
#265
06
#270
16
#275
06
#280
16
#285
06
#290
16
